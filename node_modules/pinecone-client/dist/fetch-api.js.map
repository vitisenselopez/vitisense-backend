{"version":3,"file":"fetch-api.js","sourceRoot":"","sources":["../src/fetch-api.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,IAAI,CAAC;AAQpB;;GAEG;AACH,MAAM,UAAU,iBAAiB,CAAC,IAIjC;IACC,MAAM,EAAE,OAAO,EAAE,GAAG,gBAAgB,EAAE,GAAG,IAAI,CAAC,YAAY,IAAI,EAAE,CAAC;IACjE,OAAO,EAAE,CAAC,MAAM,CAAC;QACf,SAAS,EAAE,IAAI,CAAC,OAAO;QACvB,OAAO,EAAE,EAAE,GAAG,IAAI;QAClB,OAAO,EAAE;YACP,SAAS,EAAE,IAAI,CAAC,MAAM;YACtB,GAAG,OAAO;SACX;QACD,KAAK,EAAE;YACL,WAAW,EAAE;gBACX,aAAa;gBACb,KAAK,EAAE,KAAK,EAAE,EAAE;oBACd,MAAM,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;oBAC3B,IAAI,QAAQ,IAAI,QAAQ,CAAC,IAAI,EAAE;wBAC7B,IAAI;4BACF,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC;4BAC3C,IAAI,IAAI,CAAC,OAAO,EAAE;gCAChB,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE;oCACrC,IAAI,EAAE,IAAI,CAAC,IAAI;oCACf,OAAO,EAAE,IAAI,CAAC,OAAO;oCACrB,MAAM,EAAE,QAAQ,CAAC,MAAM;oCACvB,KAAK,EAAE,KAAK;iCACb,CAAC,CAAC;6BACJ;yBACF;wBAAC,OAAO,CAAC,EAAE;4BACV,OAAO,CAAC,KAAK,CAAC,wCAAwC,EAAE,CAAC,CAAC,CAAC;yBAC5D;qBACF;oBACD,OAAO,KAAK,CAAC;gBACf,CAAC;aACF;SACF;QACD,GAAG,gBAAgB;KACpB,CAAC,CAAC;AACL,CAAC;AAID,MAAM,OAAO,aAAc,SAAQ,KAAK;IAC/B,IAAI,CAAS;IACb,OAAO,CAAyB;IAChC,MAAM,CAAS;IAEtB,YACE,OAAe,EACf,IAKC;QAED,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,+CAA+C;YAC/C,KAAK,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;SACvC;aAAM;YACL,KAAK,CAAC,OAAO,CAAC,CAAC;SAChB;QAED,8DAA8D;QAC9D,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;QAElC,4BAA4B;QAC5B,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;SACjD;QAED,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAE1B,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;SAC7B;IACH,CAAC;CACF","sourcesContent":["import ky from 'ky';\nimport type { Options } from 'ky';\n\ntype KyInstance = ReturnType<typeof ky.extend>;\nexport interface FetchOptions extends Options {\n  credentials?: 'include' | 'omit' | 'same-origin';\n}\n\n/**\n * Create an instance of Ky with options shared by all requests.\n */\nexport function createApiInstance(opts: {\n  apiKey: string;\n  baseUrl: string;\n  fetchOptions?: FetchOptions;\n}): KyInstance {\n  const { headers, ...restFetchOptions } = opts.fetchOptions || {};\n  return ky.extend({\n    prefixUrl: opts.baseUrl,\n    timeout: 30 * 1000,\n    headers: {\n      'Api-Key': opts.apiKey,\n      ...headers,\n    },\n    hooks: {\n      beforeError: [\n        // @ts-ignore\n        async (error) => {\n          const { response } = error;\n          if (response && response.body) {\n            try {\n              const body = await response.clone().json();\n              if (body.message) {\n                return new PineconeError(body.message, {\n                  code: body.code,\n                  details: body.details,\n                  status: response.status,\n                  cause: error,\n                });\n              }\n            } catch (e) {\n              console.error('Failed reading HTTPError response body', e);\n            }\n          }\n          return error;\n        },\n      ],\n    },\n    ...restFetchOptions,\n  });\n}\n\ntype PineconeErrorDetail = { typeUrl: string; value: string };\n\nexport class PineconeError extends Error {\n  public code: number;\n  public details?: PineconeErrorDetail[];\n  public status: number;\n\n  constructor(\n    message: string,\n    opts: {\n      cause?: Error;\n      code: number;\n      details?: PineconeErrorDetail[];\n      status: number;\n    },\n  ) {\n    if (opts.cause) {\n      // @ts-ignore not sure why TS can't handle this\n      super(message, { cause: opts.cause });\n    } else {\n      super(message);\n    }\n\n    // Ensure the name of this error is the same as the class name\n    this.name = this.constructor.name;\n\n    // Set stack trace to caller\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.code = opts.code;\n    this.status = opts.status;\n\n    if (opts.details) {\n      this.details = opts.details;\n    }\n  }\n}\n"]}