{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { JsonObject, RequireExactlyOne } from 'type-fest';\n\n/**\n * All metadata must extend a JSON object.\n * @see https://www.pinecone.io/docs/metadata-filtering/#supported-metadata-types\n */\nexport type RootMetadata = JsonObject;\n\n/**\n * The possible leaf values for filter objects.\n * @note Null values aren't supported in metadata for filters, but are allowed here and automatically removed for convenience.\n */\ntype FilterValue = string | number | boolean | null | string[] | number[];\ntype FilterOperator =\n  | '$eq'\n  | '$ne'\n  | '$gt'\n  | '$gte'\n  | '$lt'\n  | '$lte'\n  | '$in'\n  | '$nin';\n\n/**\n * An object of metadata filters.\n * @see https://www.pinecone.io/docs/metadata-filtering/\n */\nexport type Filter<Metadata extends RootMetadata> = {\n  [key in keyof Metadata | FilterOperator]?:\n    | FilterValue\n    | {\n        [key in keyof Metadata | FilterOperator]?: FilterValue;\n      };\n};\n\n/**\n * Sparse vector data. Represented as a list of indices and a list of corresponded values, which must be the same length.\n */\nexport type SparseValues = {\n  indices: number[];\n  values: number[];\n};\n\n/**\n * The base vector object with strongly typed metadata.\n */\nexport type Vector<Metadata extends RootMetadata> = {\n  id: string;\n  values: number[];\n  sparseValues?: SparseValues;\n  metadata?: Metadata;\n};\n\n/**\n * The parameters for a vector query.\n */\nexport type QueryParams<Metadata extends RootMetadata> = RequireExactlyOne<\n  {\n    topK: number;\n    minScore?: number;\n    filter?: Filter<Metadata>;\n    includeMetadata?: boolean;\n    includeValues?: boolean;\n    vector?: number[];\n    sparseVector?: SparseValues;\n    hybridAlpha?: number;\n    id?: string;\n  },\n  // Queries must have either a vector or an id and cannot have both.\n  'vector' | 'id'\n>;\n\ntype ScoredVector = {\n  id: string;\n  score: number;\n};\n\n/**\n * Query results without metadata or vector values.\n */\nexport type QueryResultsBase = {\n  namespace: string;\n  matches: ScoredVector[];\n};\n\n/**\n * Query results with vector values and no metadata.\n */\nexport type QueryResultsValues = {\n  namespace: string;\n  matches: Prettify<\n    ScoredVector & { values: number[]; sparseValues?: SparseValues }\n  >[];\n};\n\n/**\n * Query results with metadata and no vector values.\n */\nexport type QueryResultsMetadata<Metadata extends RootMetadata> = {\n  namespace: string;\n  matches: Prettify<ScoredVector & { metadata: Metadata }>[];\n};\n\n/**\n * Query results with metadata and vector values.\n */\nexport type QueryResultsAll<Metadata extends RootMetadata> = {\n  namespace: string;\n  matches: Prettify<\n    ScoredVector & {\n      metadata: Metadata;\n      values: number[];\n      sparseValues?: SparseValues;\n    }\n  >[];\n};\n\n/**\n * Query results with metadata and vector values narrowed by the query parameters.\n */\nexport type QueryResults<\n  Metadata extends RootMetadata,\n  Params extends { includeMetadata?: boolean; includeValues?: boolean },\n> = Params extends { includeValues: true; includeMetadata: true }\n  ? QueryResultsAll<Metadata>\n  : Params extends { includeValues: true }\n  ? QueryResultsValues\n  : Params extends { includeMetadata: true }\n  ? QueryResultsMetadata<Metadata>\n  : QueryResultsBase;\n\n/**\n * The parameters that need null values removed.\n */\nexport type NoNullParams<Metadata extends RootMetadata> = {\n  filter?: Filter<Metadata>;\n  metadata?: Metadata;\n  setMetadata?: Metadata;\n};\n\n/** Helper type to expand complex types into simple previews. */\ntype Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n"]}